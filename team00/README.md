# team00

1. [Упражнение 00 — Домен](#упражнение-00--домен)
2. [Упражнение 01 – Интерфейс](#упражнение-01-–-интерфейс)
3. [Упражнение 02. Данные](#упражнение-02-данные)
4. [Бонус - Вы захватывает дух!](#бонус---вы-захватывает-дух)


Рекомендуемая структура проекта:
```
rush00.App
	Assets/
		...
	Models/
		...
	ViewModels/
		...
	Views/
		...
	App.axaml
	Program.cs
	ViewLocator.cs
rush00.Data
	Migrations/
		...
	Models/
		Habit.cs
		HabitCheck.cs
	HabitDbContext.cs
```
### Упражнение 00 — Домен
Сегодня мы создадим собственный трекер привычек. Нам нужно иметь возможность описывать привычку и отслеживать ее развитие (или отказ) каждый день в течение заданного периода времени. На самом деле, ставьте галочки каждый день. Итак, нам нужен объект **Habit**, описывающий привычку: ее название (*Title*) и мотивация для ведения отслеживания (*Motivation*). Для привычки вам нужно будет отслеживать прогресс: он может быть установлен набором объектов *HabitCheck* для каждого из запланированных дней отслеживания, которые будут определяться *Свойства даты* и *IsChecked*. Как только все дни прошли (независимо от того, были они отмечены или нет), отслеживание завершается, и это можно отметить в свойстве *IsFinished*.

Теперь у нас есть простая модель. Мы можем отслеживать одну привычку в любое время. Это упрощение поможет нам как в развитии, так и в отслеживании этой привычки. Итак, если в системе нет незавершенного отслеживания, мы должны иметь возможность его создать, заполнив название привычки, мотивацию, дату начала и количество дней отслеживания.
Если привычка отслеживается, мы должны иметь возможность отмечать ее соблюдение или отклонение в каждый из дней (установите *IsChecked* для определенного объекта *HabitCheck*). Галочку можно поставить на любую дату.
Если отмечена последняя дата или прошел последний день отслеживания, свойство *IsFinished* объекта **Habit** должно стать истинным.

### Упражнение 01 – Интерфейс
Реализуем простой интерфейс для нашего трекера: пусть это будет **десктопное приложение**. Для разработки настольных приложений .NET огромную популярность приобрели **WPF** и **UWP**, которые являются одними из наиболее распространенных платформ. К сожалению, они очень ограничены, так как позволяют разрабатывать только в Windows.
Мы будем смотреть в сторону пользовательского интерфейса [Avalonia UI](<https://docs.avaloniaui.net/>). Это новый, но активно развивающийся кроссплатформенный **UI-фреймворк**, который разработчики называют духовным наследником технологии WPF. Он основан на разметке **XAML** и позволяет создавать настольные приложения для разных операционных систем. Наиболее часто используемый шаблон проектирования для разработки — **MVVM** .
Нам просто нужно несколько простых экранов.

### Установка привычки
Если в системе нет активной привычки отслеживания, приложение должно отобразить экран настроек.
Пользователь заполняет необходимые поля, чтобы начать отслеживание.
Обратите внимание на вводимые данные: все поля обязательны для заполнения; количество дней не должно быть отрицательным. Кнопка «старт» должна вести к следующему экрану.

### Отслеживание
Если для отслеживания задана привычка отслеживания (или она была заполнена на предыдущем шаге), пользователь должен увидеть экран отслеживания. Здесь у них есть возможность отметить каждый из дней.

Важно обрабатывать каждый тик (**событие Checked** каждого объекта **CheckBox**), чтобы установить и сохранить его в модели. Не забудьте проверить, завершено ли отслеживание!
Приведенные выше скриншоты программы помогут понять, что именно нужно реализовать.
Обязательно используйте [официальную документацию AvaloniaUI](<https://docs.avaloniaui.net/>) — там вы найдете описание всех необходимых [компонентов](<https://docs.avaloniaui.net/guides/basics>), основы технологии и [туториалы](<https://docs.avaloniaui.net/tutorials/todo-list-app>) двух простых проектов, которые помогут вам понять и освоить основные принципы разработки. Кроме того, читайте о [DataContext](<https://rachel53461.wordpress.com/2012/07/14/what-is-this-datacontext-you-speak-of/>).


## Упражнение 02. Данные
Все, что вам осталось сделать, это убедиться, что данные не сохраняются только в памяти во время работы приложения. Пусть каждый запуск приложения работает с актуальным и сохраненным набором данных. Для этого нам понадобится **база данных** — возьмем самый простой вариант и будем хранить все в одном файле с помощью **SQLite**.

Дни прямого доступа к базам данных и написания SQL-запросов прямо из приложения прошли. Разработка становится все более абстрактной и высокоуровневой, а для доступа к данным чаще всего используются различные **ORM**. Эта технология позволяет общаться с базами данных в контексте ООП-объектов, а не таблиц данных и SQL-запросов, фактически позволяя проецировать данные из базы данных непосредственно в объекты приложения (и наоборот).

Приложения .NET используют **Entity Framework**, и наиболее распространенным подходом является **Code First**. Что это значит?

То есть, имея в приложении описание нашей предметной модели в виде классов *Habit* и *HabitCheck* , мы можем настроить его так, чтобы база данных и соответствующие таблицы создавались сами на основе нашего кода. И при любом изменении кода в них **схема БД** будет обновляться с помощью механизма миграции, встроенного в Entity Framework.

Далее мы можем просмотреть данные из базы данных как набор соответствующих объектов и получить к ним доступ с помощью запросов LINQ.

Начнем с разделения кода на два проекта: *rush00.App* и *rush00.Data* . В первом будет вся логика отображения нашего приложения, во втором — модели предметной области. Чтобы проверить себя, спросите себя: что будет, если я решу использовать другой способ ввода и вывода информации, а вместо настольного приложения это веб-приложение или консольное приложение?

При таком разделении можно легко повторно использовать проект, реализующий основную логику, и просто подключить к нему другое приложение с новой точкой входа.

Установите пакеты **Microsoft.EntityFrameworkCore.Tools** и **Microsoft.EntityFrameworkCore.Sqlite** с помощью диспетчера **nuget**.

Для работы с данными создайте класс *HabitDbContext* и наследуйте его от Microsoft.EntityFrameworkCore.DbContext. Это будет [основной сервис](<https://www.entityframeworktutorial.net/efcore/entity-framework-core-dbcontext.aspx>) для работы с объектами из БД. В *HabitDbContext* будет две наши коллекции:
```
DbSet<Habit> Habits
DbSet<HabitCheck> HabitChecks
```
Чтобы использовать контекст доступа к данным базы данных SQLite, добавьте в *HabitDbContext*:
```
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
	optionsBuilder.UseSqlite("Filename=habits.db");
}
```
Теперь [настройте миграции](<https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli>), для этого достаточно использовать команду:
```
dotnet ef migrations add {MigrationName}
```
В вашем проекте должна появиться папка с миграциями, проверьте, какой код был сгенерирован и какие таблицы будут с ним созданы. Не забудьте добавить поля *Id* в объекты *Habit* и *HabitCheck*!

Далее созданные миграции нужно «применить» к нашей базе с помощью команды:
```
dotnet ef database update
```
Или добавьте в App.axaml.cs код, который будет проверять и накатывать миграции нашего контекста при запуске приложения:
```
using (var context = new HabitDbContext())
{
	context.Database.EnsureCreated();
}
```
Обратите внимание на **используемую** конструкцию.

Теперь, когда база данных существует, нам просто нужно использовать экземпляр класса *HabitDbContext* и получить доступ к коллекциям его объектов *Habit* и *HabitCheck* с помощью методов LINQ.

Например, получение актуального отслеживания привычки будет выглядеть так:
```
using (var context = new HabitDbContext())
{
	var habit = _dbContext.Habits
                	.Include(x => x.HabitChecks)
                	.FirstOrDefault(x => !x.IsFinished);
}
```
Обратите внимание на [метод Include](<https://learn.microsoft.com/en-us/ef/ef6/querying/related-data>), он позволяет подгружать связанные данные по внешнему ключу.

Если вы сохраняете в базу данных с помощью метода Add или редактируете поля объектов базы данных, не забудьте сохранить изменения с помощью [метода SaveChanges()](<https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechanges?view=efcore-5.0>).

Подключите БД к вашему коду, чтобы:
- При запуске приложения проверяется, есть ли в базе привычка с текущим отслеживанием.
- Если такового нет, привычка может быть создана в БД, создается коллекция HabitChecks для всех дат отслеживания БД.
- Если он существует (или был только что создан), отображается экран с датами и галочками для актуальной информации из БД.
- Галочка на дату в трекинге записывается в БД.
- Тик завершения записывается в БД.

## Бонус - Вы захватывает дух!
В качестве бонусного задания сделайте так, чтобы в конце отслеживания привычки (*IsFinished == true*) выводилось поздравительное сообщение с количеством отработанных дней и текстом мотивации.

## Самооценочный тест
- При первом запуске приложение предлагает заполнить информацию для создания трекера привычек.
- Когда вы перезапускаете приложение, оно отображает список дат созданной привычки.
- Для созданной привычки с отмеченными днями при перезапуске отображаются те же дни.