# d06

1. [Упражнение 00 – Законы мира](#упражнение-00-–-законы-мира)
2. [Упражнение 01 – Гонка за ресурсами](#упражнение-01-–-гонка-за-ресурсами)
3. [Упражнение 02 – Параллели](#упражнение-02-–-параллели)
4. [Упражнение 03 – Готово](#упражнение-03-–-готово)
5. [Упражнение 04 – Готово, вперед!](#упражнение-04-–-готово-вперед)
6. [Бонус Немного случайно](#бонус-немного-случайно)

### Упражнение 00 – Законы мира
Кассовые аппараты не справляются с покупателями и их покупками моментально. Добавьте в класс *CashRegister* два новых свойства : время, которое кассир тратит на каждый товар в корзине, и время, которое кассир тратит на переключение между покупателями. Для простоты пусть это будет количество секунд. Решите для себя, хотите ли вы использовать **тип TimeSpan**.

Пусть эти параметры будут определены глобально для магазина: реализуйте это в конструкторах классов CashRegister и Store . Измените приложение так, чтобы значения этих параметров (в секундах) брались при запуске из конфигурации приложения в файле *appsettings.json*. Предполагается, что все кассы магазина работают и заряжаются параллельно , не так ли? Каждый в своем потоке.

Реализуем эмуляцию занятости одной кассы: добавим в *CashRegister* метод *Process*, в рамках которого будет обрабатываться один покупатель. В методе [приостановить текущий поток обработки](<https://learn.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads>) на время, соответствующее времени обработки одного покупателя и всех его товаров. Не забудьте посчитать это время!

Добавьте в класс *CashRegister* свойство, которое позволит вам получить полное время загрузки кассового аппарата. Сначала сделайте это время равным нулю, но увеличивайте его каждый раз, когда обрабатывается новый пользователь, увеличивая время, затраченное на общую обработку. Мы эмулировали загрузку кассового аппарата. Попробуйте отладить его и посмотреть, правильно ли выполняются задержки.

### Упражнение 01 – Гонка за ресурсами
В нашей модели каждый клиент забирает товар с одного и того же склада — за его работу отвечает класс *Storage*. И если касс может быть много, то хранилище магазина все равно одно. Это означает, что параллельные кассы требуют ограниченное количество товаров в одном хранилище, что создает конкуренцию.

При использовании нескольких потоков важно понимать, что они могут блокировать общие ресурсы. Кроме того, этот блок важен для обеспечения **согласованности** данных . Для более глубокого понимания обратитесь к [лучшим практикам](<https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices>).

Добавим в класс Storage метод , позволяющий забрать необходимое количество товаров со склада. Используйте инструменты класса [Interlocked](<https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0>) , чтобы обеспечить **потокобезопасный механизм блокировки** ресурсов.

### Упражнение 02 – Параллели
Теперь, когда мы реализовали работу каждой отдельной кассы и механизм «покупки» товаров со склада, давайте сделаем так, чтобы магазин запускал все кассы параллельно.

Добавьте в класс Store метод *OpenRegisters*, который будет [запускать отдельный поток](<https://learn.microsoft.com/en-us/dotnet/standard/threading/creating-threads-and-passing-data-at-start-time>) для всех касс магазина: пока на складе есть товары, каждая касса должна последовательно обрабатывать каждого покупателя в своей очереди. При этом «покупка» должна производиться с уменьшением соответствующего количества товара на складе.

Создайте магазин с несколькими кассами и вручную добавьте в их очереди несколько покупателей с товарами. Проверьте себя отладкой, все ли работает корректно? Вывести информацию о каждом покупателе на кассе в консоль.

### Упражнение 03 – Готово
Теперь давайте обратимся к последней части нашего уравнения: клиентам. Параллельно делают и выбор кассы, давайте это реализуем. Когда магазин начнет свою работу, пусть у него уже есть какое-то начальное количество покупателей.

Допустим, у нас есть 20 клиентов на старте. Создайте их и сделайте так, чтобы до того, как магазин откроет свои кассы, каждый из этих покупателей наполнил свою тележку и встал в очередь на кассу, но делал это параллельно.

Здесь вам помогут инструменты [PLINQ , обратите внимание на метод](<https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq>) **Parallel.Foreach**. Имейте в виду, что вам придется изменить тип очереди Customer в классе *CashRegister* на **ConcurrentQueue**. Почему это?

Мы обеспечили наш магазин стартовыми клиентами и их параллельным подбором очереди. Попробуйте отладить свой код и посмотреть, все ли работает правильно.

### Упражнение 04 – Готово, вперед!
Добавить код приложения для имитации следующей ситуации:
Есть магазин, в котором одновременно работают 4 кассы, а его склад вмещает до 50 товаров. У каждого покупателя может быть от 1 до 7 товаров в корзине. Зарядка одного предмета занимает 2 секунды. Смена клиента занимает 4 секунды. Пока магазин открыт, новый покупатель появляется каждые 7 секунд.

Когда кассы начинают работать, в магазине уже 10 покупателей. Вам необходимо смоделировать два режима работы магазина.
Клиенты всегда выбирают самую короткую очередь. Новые клиенты всегда выбирают очередь с наименьшим количеством клиентов, предполагая, что очередь движется быстрее.

Покупатели выбирают очередь с наименьшим количеством товаров. Новые клиенты всегда выбирают очередь с наименьшим количеством товаров в своих корзинах, исходя из предположения, что очередь, в которой у клиентов меньше корзин, движется быстрее.

Для каждого покупателя, совершившего покупку, вывести в консоль: касса, покупатель, количество товаров в корзине, количество покупателей в очереди за ним. После закрытия магазина выведите для каждой кассы: кассу, среднее время пребывания покупателя в очереди на данной кассе (для этого у вас есть общее время обработки всех и количество прошедших покупателей).

### Бонус Немного случайно
Изменить код приложения, чтобы время обработки одного покупателя и одного товара на каждой кассе было не постоянной величиной, глобальной для всего магазина, а рассчитывалось как случайное количество секунд от 1 до заданного максимума (ранее использовавшегося и определены в параметрах appsettings.json *timePerItem* и *timePerCustomer*). На каждую кассу.

Для каждого покупателя, совершившего покупку, вывести в консоль: касса, покупатель, количество товаров в корзине, количество покупателей в очереди за ним. После закрытия магазина выведите для каждой кассы: кассу, среднее время пребывания покупателя в очереди на данной кассе (для этого у вас есть общее время обработки всех и количество прошедших покупателей).