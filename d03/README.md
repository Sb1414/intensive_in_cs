# d03

1. [Упражнение 00 – Конфигурация](#упражнение-00-–-конфигурация)
2. [Упражнение 01 — JSON](#упражнение-01--json)
3. [Упражнение 02 — YML](#упражнение-02--yaml)
4. [Упражнение 03 – Исключения](#упражнение-03-–-исключения)
5. [Упражнение 04 – Приоритеты](#упражнение-04-–-приоритеты)

Структура проекта:
```
d03/
	Program.cs
    Configuration/
        Configuration.cs
        Sources/
            IConfigurationSource.cs
            YamlSource.cs
            JsonSource.cs
```
### Упражнение 00 – Конфигурация
Для обработки и хранения параметров реализовать класс *Configuration*. Он должен содержать коллекцию *Params* — набор параметров, необходимых для работы приложения, словарь ключ-значение. Ключи должны быть уникальными, поэтому хэш-таблицы — хороший выбор для этого.

Помните о **принципе единой ответственности**: класс *Configuration* ничего не должен знать об источниках данных, будь то JSON, YAML или что-то еще. Поэтому давайте извлечем общий интерфейс *IConfigurationSource* для реализации разных источников. Он будет отвечать за загрузку данных из файла и иметь метод, возвращающий набор параметров.

Реализуйте конструктор класса *Configuration*, чтобы он принимал коллекцию параметров *IConfigurationSource* и заполнял ими коллекцию *Params*.

Так будет сохранен принцип **инверсии зависимостей**: класс *Configuration* будет зависеть от абстракции *IConfigurationSource* , а не от конкретных реализаций данного интерфейса. Позже, если вы решите добавить новые источники, вам не придется переписывать конфигурацию.

### Упражнение 01 — JSON
Реализуйте класс *JsonSource* , потомок *IConfigurationSource*. Единственным конструктором класса должен быть конструктор, принимающий путь к файлу json, откуда будет загружаться конфигурация. Чтобы превратить файл JSON в Hashtable, используйте встроенные инструменты System.Text.Json.

Мы предполагаем, что структура параметров в файлах плоская, и здесь нет вложенных данных.

Создайте экземпляр класса *Configuration* , используя *JsonSource* , заполненный из файла config.json. Вывести конфигурацию в консоль в следующем формате:
```
Configuration
{Key}: {Value}
{Key}: {Value}
...
{Key}: {Value}
```
#### Входные параметры
```
$ dotnet run “{filePath}”
```
|Аргумент|Тип|Описание|
|---|---|---|
| filePath |string | Путь к json-файлу |

#### Пример запуска приложения из папки проекта
```
Configuration
Port: 1234
CheckForUpdates: True
Domain: http://localhost
Source: JSON
```

### Упражнение 02 — YAML
Реализуйте класс *YamlSource* , потомок *IConfigurationSource*. Единственным конструктором класса должен быть конструктор, принимающий путь к yaml-файлу, откуда будет загружаться конфигурация. Пока нет встроенных инструментов для получения Hashtable из файла YAML , но это не имеет большого значения. Дело в том, что любая разработка, так или иначе, — это командная работа, и для обмена полезным кодом есть инструмент nuget . Подключайтесь и используйте пакет YamlDotNet .

Мы предполагаем, что структура параметров в файлах плоская, и здесь нет вложенных данных.

Создайте экземпляр класса *Configuration* , используя *YamlSource* , заполненный из файла config.yml. Вывести конфигурацию в консоль в следующем формате:
```
Configuration
{Key}: {Value}
{Key}: {Value}
...
{Key}: {Value}
```
#### Входные параметры
```
$ dotnet run “{filePath}”
```
|Аргумент|Тип|Описание|
|---|---|---|
| filePath |string | Путь к файлу yaml |
#### Пример запуска приложения из папки проекта
```
Configuration
CheckForUpdates: false
Port: 8080
Source: YAML
Application: ex03
```

### Упражнение 03 – Исключения
Десериализация файлов неправильного формата может привести к возникновению исключений в приложении. Это нормально, если исключение обрабатывается .

Добавьте вызов классов обработки конфигурации для перехвата исключений, возникающих во время десериализации. В этом случае нужно вывести ошибку о некорректных данных:
```
Invalid data. Check your input and try again.
```

### Упражнение 04 – Приоритеты
Класс *Configuration* будет создан путем сбора данных из разных источников. Однако окончательный набор параметров, который будет иметь отношение к приложению, должен быть один. Поэтому у вас должна быть возможность объединять одноименные параметры из разных источников конфигураций. Это означает, что каждый из источников должен иметь параметр *Priority*, чтобы конфигурация могла определить, в каком порядке она будет загружать и объединять данные.

Добавьте в интерфейс *IConfigurationSource* свойство , отображающее приоритет источника конфигурации. Свойство должно быть закрытым для редактирования и заполняемым из конструктора класса.

Добавить *конфигурацию*, чтобы приоритет учитывался при загрузке конфигураций из разных источников.

Создайте экземпляр класса *Configuration* с конфигурацией из двух источников: *YamlSource* и *JsonSource*. Задайте путь к файлам и их приоритет из консоли при запуске приложения.

Вывести конфигурацию в консоль в следующем формате:
```
Configuration
{Key}: {Value}
{Key}: {Value}
...
{Key}: {Value}
```
#### Входные параметры
```
$ dotnet run “{jsonPath}” {jsonPriority} “{yamlPath}” {yamlPriority}
```
|Аргумент|Тип|Описание|
|---|---|---|
| jsonPath |string | Путь к json-файлу |
| jsonPriority |int | Приоритет файла json |
| yamlPath |string | Путь к файлу yaml |
| yamlPriority |int | Приоритет файла yaml |

#### Пример запуска приложения из папки проекта
```
$ dotnet run “pathToJson” 1 “pathToYaml” 2
Configuration
Source: YAML
Application: ex03
CheckForUpdates: false
Domain: http://localhost
Port: 8080
```
```
$ dotnet run “pathToJson” 1 “pathToYaml” 0
Configuration
CheckForUpdates: True
Application: ex03
Port: 1234
Source: JSON
Domain: http://localhost
```