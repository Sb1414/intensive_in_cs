# d01
1. [Упражнение 00 — Хранение](#упражнение-00--хранение)
2. [Упражнение 01 – Клиенты](#упражнение-01-–-клиенты)
3. [Упражнение 02 – Корзина для покупок](#упражнение-02-–-корзина-для-покупок)
4. [Упражнение 03 – Кассовый аппарат](#упражнение-03-–-кассовый-аппарат)
5. [Упражнение 04 – Сохранение](#упражнение-04-–-сохранение)
6. [Упражнение 05 – Очереди](#упражнение-05-–-очереди)
7. [Упражнение 06 – Как это работает?](#упражнение-06-–-как-это-работает)

## Упражнение 00 — Хранение
Нужно создать класс Storage и описать его свойства. Главное для нас то, что склад определяется целым числом товаров (условно одинаковых), которые в нем хранятся.

Количество товара может варьироваться, но на момент создания хранилища оно определяется его вместимостью - начальной стоимостью. Пусть в конструкторе класса указано количество товаров. Хранилище нельзя создать без емкости, поэтому у него не должно быть конструктора без параметров.

Добавить в класс метод IsEmpty, который будет возвращать информацию о товарах, которых нет в наличии. Использовать лямбда-оператор.

## Упражнение 01  – Клиенты
Создать класс Customer и описать его свойства. Сделать так, чтобы одного покупателя можно было отличить от другого: пусть у него будет имя и порядковый номер, под которым он зашел в магазин. Поскольку классы наследуются от типа Object и получают доступ к его методам, переопределить метод ToString(), чтобы он возвращал строковую информацию с номером и именем клиента.
```
Andrew, customer #1
```
Номер и название не меняются. Сделать эти автосвойства заблокированными для редактирования извне и задавать только из конструктора класса. Заказчик не может быть создан без них, поэтому у него не должно быть конструктора без параметров.

Попробуйте создать двух клиентов с одинаковыми именами и номерами:
```
var customer1 = new Customer("Andrew", 1);
var customer2 = new Customer("Andrew", 1);
```
Вывести значение выражения customer1 == customer2 в консоль. Почему ответ такой?

Изменить класс Customer , чтобы вывод на консоль был верным.

## Упражнение 02 – Корзина для покупок
Возьмем класс Customer из предыдущего упражнения, добавим ему свойство, отражающее количество товаров в его корзине. Когда клиент создается (в реальном мире, когда он появляется в магазине), у него нет товаров.

Чтобы пользователи ваших классов не могли изменять значение как им вздумается, сделайте поле с количеством товаров не изменяемым извне.

Вместо этого добавьте клиенту метод заполнения корзины FillCart: пусть метод берет максимальную вместимость корзины (входной аргумент) и заполняет количество товаров клиента случайным числом (минимум 1, максимальная вместимость корзины).

Вот так мы реализовали логику наполнения корзины в одном месте и закрыли ее удобным методом с читаемым и понятным названием. Добро пожаловать в инкапсуляцию.

Создайте 3 пользователей, заполните их корзины вместимостью 15 товаров. Вывести в консоль информацию о пользователе и количестве товаров в его корзине.

Пример:
```
Andrew, customer #1 (5 items in cart)
```

## Упражнение 03 – Кассовый аппарат
Создать класс CashRegister и описать его свойства. Пусть у кассы есть «имя» — некий заголовок, который позволит покупателям четко понимать, о какой кассе идет речь. Переопределить методы класса, чтобы ToString() возвращал название и две кассы с одинаковые заголовки равны.
```
Register #1
```
У кассового аппарата не должно быть конструктора без параметров. Также не должно быть очередей на кассе. Но мы живем в реальном мире и хотим построить модель для реального мира, поэтому давайте реализуем очереди.

Добавить коллекцию Customers в класс CashRegister, чтобы это была очередь типа «первым пришел, первым обслужен».

## Упражнение 04 – Сохранение
Создать класс Store и описать его свойства. В магазине должен быть склад и комплект кассовых аппаратов.

Реализовать конструктор класса так, чтобы он принимал на вход целочисленную емкость хранилища и целое число кассовых аппаратов. Заполнить свойства класса в конструкторе, используя эти входные данные. Пусть каждый кассовый аппарат будет создан с названием, соответствующим его порядковому номеру.

Подумать, есть ли смысл блокировать сеттер кассовой коллекции от редактирования?

Добавьте метод IsOpen , возвращающий true, если на складе еще есть товар.

## Упражнение 05 – Очереди
Как вы стоите в очереди? К кассе с наименьшим количеством покупателей или к кассе с наименьшим количеством покупок? Давайте реализуем обе ситуации.

Создайте статический класс CustomerExtensions с двумя методами расширения для объекта Customer : оба метода будут принимать набор кассовых аппаратов ( объекты CashRegister ) и возвращать кассовый аппарат, выбранный покупателем. Первый способ — касса с наименьшим количеством покупателей, второй — с наименьшим количеством товаров среди всех покупателей в очереди этой кассы.

Не забудьте назвать методы, чтобы было понятно, что именно они делают. Теперь у вас есть отдельный класс, отвечающий за выбор очереди (мы разделили ответственность) и удобный способ вызова этих методов в коде. Попробовать их.

## Упражнение 06 – Как это работает?
Создать магазин с 3 кассами и складом на 40 товаров. Создать 10 разных клиентов. Реализовать цикл: пусть каждый из покупателей наполнит корзину и встанет в очередь. Цикл должен работать, пока магазин открыт (у нас есть способ это проверить) и в нем есть покупатели.

Заполнение корзины покупателя товарами должно снимать их со склада. Реализовать его самостоятельно. Клиенты выходят из очереди после того, как они получают свои товары со склада. У клиентов не может быть больше предметов, оставшихся на складе (на складе не может быть меньше 0 предметов). Если хранилище пусто, а в корзине покупателя еще есть товары для покупки, вывести на консоль:
```
Andrew, Customer #4 (2 items left in cart)
```
Проделать это для двух разных случаев выбора очереди и в каждом случае вывести имя и номер пользователя, количество товаров, выбранную кассу и количество людей на кассе, количество товаров в корзинах очереди на консоль в цикле.
```
Andrew, Customer #4 (6 items in cart) - Register #1 (4 people with 20 items behind)
```
Вместимость тележки 7 штук.